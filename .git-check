
#!/usr/bin/env bash
# git ck: Universal health check script for GitHub & Bitbucket
set -euo pipefail
trap 'echo "ðŸ’¥ Command \"$BASH_COMMAND\" (line $LINENO) failed"; exit 1' ERR

default_remote=${1:-origin} # Renamed to avoid confusion with loop variable

echo "ðŸ” Checking Git version:"
git --version

echo
echo "=== 1. Branch & Upstream ==="
# Get current branch name
branch=$(git rev-parse --abbrev-ref HEAD)
echo "â€¢ Branch: $branch"

# Check if an upstream is set and get its name
# Using @{u} is a more direct way to get the upstream ref name
if upstream_full_name=$(git rev-parse --symbolic-full-name "$branch@{upstream}" 2>/dev/null); then
Â  upstream_short_name=$(git rev-parse --abbrev-ref "$branch@{upstream}")
Â  echo "â€¢ Upstream: $upstream_short_name"

Â  # Determine the remote name for the current branch's upstream
Â  current_branch_remote=$(git config "branch.$branch.remote")
Â  if [ -z "$current_branch_remote" ]; then
Â Â Â  echo "âš ï¸ Could not determine remote for upstream $upstream_short_name. Using '$default_remote' for fetch."
Â Â Â  current_branch_remote="$default_remote"
Â  fi

Â  echo "â€¢ Fetching from '$current_branch_remote' for upstream checks..."
Â  git fetch -q "$current_branch_remote"

Â  counts=$(git rev-list --left-right --count "$upstream_full_name"...HEAD)
Â  behind=${counts%% *}
Â  ahead=${counts##* }
Â  echo "â€¢ Behind/Ahead: $behind/$ahead"
else
Â  echo "âš ï¸ No upstream set for branch '$branch'. To set one:"
Â  echo "Â Â  git branch --set-upstream-to=$default_remote/$branch $branch"
Â  echo "Â Â  Or, after your next push: git push -u $default_remote $branch"
fi
git status -sb

echo
echo "=== 2. Remotes & Authentication ==="
parse_host() {
Â  echo "$1" | sed -E -e 's#^ssh://git@##' -e 's#^git@##' -e 's#^https?://##' -e 's#^[^@]+@##' -e 's#[:/].*$##'
}

remotes_found=$(git remote)
if [ -z "$remotes_found" ]; then
Â  echo "âš ï¸ No remotes found in this repository."
else
Â  for r in $remotes_found; do
Â Â Â  url=$(git remote get-url "$r")
Â Â Â  host=$(parse_host "$url")
Â Â Â  echo "â€¢ Remote '$r' â†’ $url (Host: $host)"

Â Â Â  if [[ $url =~ ^git@|^ssh:// ]]; then
Â Â Â Â Â  echo "Â  Testing SSH for remote '$r'..."
Â Â Â Â Â  if git ls-remote --exit-code --heads "$r" &>/dev/null; then
Â Â Â Â Â Â Â  echo "Â  âœ… SSH OK for '$r'"
Â Â Â Â Â  else
Â Â Â Â Â Â Â  echo "Â  âŒ SSH authentication or connection failed for remote '$r'."
Â Â Â Â Â Â Â  echo "Â Â Â Â  Attempting 'ssh -vT git@$host' for diagnostics (output may follow):"
Â Â Â Â Â Â Â  ssh -vT "git@$host" 2>&1 || true
Â Â Â Â Â Â Â  echo "Â  âŒ SSH test failed for '$r'. Check SSH keys, agent, and host access."
Â Â Â Â Â Â Â  # Consider not exiting immediately: # exit 1
Â Â Â Â Â  fi
Â Â Â  elif [[ $url =~ ^https?:// ]]; then
Â Â Â Â Â  echo "Â  Testing HTTPS for remote '$r'..."
Â Â Â Â Â  if git ls-remote --exit-code --heads "$r" &>/dev/null; then
Â Â Â Â Â Â Â  echo "Â  âœ… HTTPS OK for '$r'"
Â Â Â Â Â  else
Â Â Â Â Â Â Â  echo "Â  âŒ HTTPS connection failed for remote '$r'. Token/Password might be invalid or network issue."
Â Â Â Â Â Â Â  echo "Â Â Â Â  Please check your credential manager or saved credentials."
Â Â Â Â Â Â Â  # Consider not exiting immediately: # exit 1
Â Â Â Â Â  fi
Â Â Â  else
Â Â Â Â Â  echo "Â  â„¹ï¸ Remote '$r' uses an unrecognized URL scheme: $url"
Â Â Â  fi
Â  done
fi

echo
echo "=== 3. Git LFS ==="
if command -v git-lfs &>/dev/null; then
Â  echo "â€¢ git-lfs is installed: $(git lfs version | head -n 1)"
Â  if git lfs env | grep -q 'git config filter.lfs.process'; then # More robust check for LFS init
Â Â Â  if git lfs env | grep -i -q "Endpoint="; then
Â Â Â Â Â  git lfs env | grep -i "Endpoint=" | sed 's/^[[:space:]]*//'
Â Â Â  else
Â Â Â Â Â  echo "âš ï¸ LFS seems initialized, but no specific LFS endpoint (lfs.url) is configured."
Â Â Â Â Â  echo "Â Â  LFS will likely use the main remote URL. This is often fine."
Â Â Â  fi
Â Â Â  echo "â€¢ Checking for untracked LFS pointers..."
Â Â Â  # Using ls-files for a faster check than 'git lfs status' for this specific problem
Â Â Â  # This finds files that *have* LFS attributes but are not actual LFS pointers yet (e.g. added but not committed after lfs track)
Â Â Â  # or files that *are* pointers but somehow not tracked correctly. A bit complex.
Â Â Â  # A simpler check might be to see if `git lfs ls-files` shows anything unexpected.
Â Â Â  # For now, keeping the previous check, but it can be refined.
Â Â Â  # This check is more about "are there files that *should* be LFS but are not pointers"
Â Â Â  # git ls-files -- ':(attr:filter=lfs)' might list files that *should* be handled by LFS.
Â Â Â  # git ls-files -s -- ':(attr:filter=lfs)' | awk '$1 == "120000" { print $4 }' could find symlinks that should be LFS
Â Â Â  # A truly robust check here is tricky. Let's simplify for now.
Â Â Â  lfs_files_in_index=$(git lfs ls-files 2>/dev/null | wc -l | awk '{print $1}')
Â Â Â  if [ "$lfs_files_in_index" -gt 0 ]; then
Â Â Â Â Â Â Â  echo "âœ… LFS is tracking $lfs_files_in_index file(s) in the index."
Â Â Â Â Â Â Â  # A more advanced check could involve 'git lfs fsck --dry-run' but it's slow.
Â Â Â  else
Â Â Â Â Â Â Â  echo "â„¹ï¸ No files currently tracked by LFS in the index, or LFS is not fully initialized."
Â Â Â  fi
Â  else
Â Â Â  echo "âš ï¸ git-lfs is installed, but not initialized for this repository (no LFS filters found)."
Â Â Â  echo "Â Â  Run 'git lfs install' (once per user) and then 'git lfs install' (per repo, or 'git lfs install --system')."
Â Â Â  echo "Â Â  Then 'git lfs track \"*.largefile\"' and 'git add .gitattributes'."
Â  fi
else
Â  echo "âš ï¸ git-lfs not installed. If this repository uses LFS, large files might not be handled correctly."
fi

echo
echo "=== 4. GPG Signature ==="
# Show GPG signature of the latest commit if available
if ! latest_commit_hash=$(git rev-parse HEAD 2>/dev/null); then
Â Â Â  echo "â„¹ï¸ No commits in repository to check for GPG signature."
elif signature_log_output=$(git log -1 --show-signature "$latest_commit_hash" 2>/dev/null); then
Â Â Â  if echo "$signature_log_output" | grep -Eq 'gpg: Signature made|gpg: Good signature from'; then
Â Â Â Â Â Â Â  echo "â€¢ Latest commit signature details ($latest_commit_hash):"
Â Â Â Â Â Â Â  echo "$signature_log_output" | grep -E --color=never '^gpg:|^commit ' | sed -n '1,/^gpg: \(Good signature\|Signature made\)/p' | head -n 5
Â Â Â  elif echo "$signature_log_output" | grep -q "gpg: BAD signature"; then
Â Â Â Â Â Â Â  echo "âš ï¸ Latest commit ($latest_commit_hash) has a BAD GPG signature!"
Â Â Â Â Â Â Â  echo "$signature_log_output" | grep --color=never "gpg:" | head -n 3
Â Â Â  elif echo "$signature_log_output" | grep -q "gpg: Note: This key has expired!"; then
Â Â Â Â Â Â Â  echo "âš ï¸ Latest commit ($latest_commit_hash) signed with an EXPIRED GPG key!"
Â Â Â Â Â Â Â  echo "$signature_log_output" | grep --color=never "gpg:" | head -n 3
Â Â Â  elif echo "$signature_log_output" | grep -q "gpg:"; then
Â Â Â Â Â Â Â  echo "â„¹ï¸ Latest commit ($latest_commit_hash) has a GPG signature, but its status is unclear from simple checks:"
Â Â Â Â Â Â Â  echo "$signature_log_output" | grep --color=never "gpg:" | head -n 3
Â Â Â  else
Â Â Â Â Â Â Â  commit_author_email=$(git log -1 --pretty=format:'%ae' "$latest_commit_hash")
Â Â Â Â Â Â Â  signing_key=$(git config --get user.signingkey || true)
Â Â Â Â Â Â Â  commit_signing=$(git config --get commit.gpgsign || true)

Â Â Â Â Â Â Â  echo "âš ï¸ Latest commit ('${latest_commit_hash:0:7}') is not GPG signed (or signature not found)."
Â Â Â Â Â Â Â  if [ "$commit_signing" = "true" ]; then
Â Â Â Â Â Â Â Â Â Â Â  echo "Â Â  However, 'commit.gpgsign' is true in your Git config."
Â Â Â Â Â Â Â Â Â Â Â  if [ -n "$signing_key" ]; then
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  echo "Â Â  Your 'user.signingkey' is set to: $signing_key"
Â Â Â Â Â Â Â Â Â Â Â  else
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  echo "Â Â  No specific 'user.signingkey' is set in your Git config."
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  echo "Â Â  GPG might attempt to use a default key for '$commit_author_email'."
Â Â Â Â Â Â Â Â Â Â Â  fi
Â Â Â Â Â Â Â Â Â Â Â  echo "Â Â  This could indicate a GPG setup issue, or the last commit was made with --no-gpg-sign."
Â Â Â Â Â Â Â  else
Â Â Â Â Â Â Â Â Â Â Â  echo "Â Â  To enable GPG signing for commits:"
Â Â Â Â Â Â Â Â Â Â Â  echo "Â Â  1. Ensure GPG is installed and a key is generated."
Â Â Â Â Â Â Â Â Â Â Â  echo "Â Â  2. Configure Git: git config --global user.signingkey YOUR_KEY_ID"
Â Â Â Â Â Â Â Â Â Â Â  echo "Â Â  3. Enable auto-signing: git config --global commit.gpgsign true"
Â Â Â Â Â Â Â  fi
Â Â Â  fi
else
Â Â Â  echo "â„¹ï¸ Could not retrieve GPG signature status for the latest commit ($latest_commit_hash)."
fi


echo
echo "=== 5. Staged Changes Size ==="
added_lines=$(git diff --cached --numstat | awk '{s+=$1} END {print s+0}')
deleted_lines=$(git diff --cached --numstat | awk '{s+=$2} END {print s+0}')

if (( added_lines > 100000 )); then
Â  echo "âš ï¸ Staged changes are substantial: +$added_lines / -$deleted_lines lines. Possible large files or many changes!"
elif (( added_lines > 0 || deleted_lines > 0 )); then
Â  echo "âœ… Staged changes: +$added_lines / -$deleted_lines lines."
else
Â  echo "âœ… No staged changes."
fi

echo
echo "âœ¨ Health check complete."
